<!DOCTYPE html>
<!-- v14 2026-01-06 dynamic-legend -->
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Malten Map</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #f5f5f5;
            overflow: hidden;
        }
        #map-container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; background: #fff; }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            color: #333;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        #stats strong { font-size: 14px; }
        #legend {
            position: absolute;
            bottom: 50px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            color: #333;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .legend-item { display: flex; align-items: center; margin: 3px 0; }
        .legend-emoji { width: 18px; text-align: center; margin-right: 6px; font-size: 12px; }
        
        /* Legend toggle button - always visible */
        #legend-toggle {
            display: block;
            position: absolute;
            bottom: 60px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 18px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 100;
        }
        
        /* Legend hidden by default, shown on toggle */
        #legend { display: none; }
        #legend.show { display: block; bottom: 120px; }
        
        @media (max-width: 600px) {
            #stats { font-size: 11px; padding: 8px 12px; }
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            max-width: 200px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #controls button {
            background: rgba(255,255,255,0.95);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        #controls button:hover { background: #fff; }
        #scale {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .scale-bar {
            height: 4px;
            background: #333;
            margin-top: 4px;
        }
        #place-popup {
            position: absolute;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            padding: 16px;
            min-width: 220px;
            max-width: 300px;
            z-index: 200;
            display: none;
        }
        #place-popup h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #place-popup .category {
            color: #666;
            font-size: 13px;
            margin-bottom: 8px;
        }
        #place-popup .coords {
            color: #999;
            font-size: 11px;
            margin-bottom: 12px;
        }
        #place-popup .actions {
            display: flex;
            gap: 8px;
        }
        #place-popup .actions a {
            flex: 1;
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            background: #4285f4;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
        }
        #place-popup .actions a:hover {
            background: #3367d6;
        }
        #place-popup .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #999;
        }
    </style>
</head>
<body>
<div id="map-container">
    <canvas id="map"></canvas>
    <div id="stats">Loading...</div>
    <button id="legend-toggle" onclick="toggleLegend()">‚ÑπÔ∏è</button>
    <div id="legend">
        <!-- Dynamic legend - populated based on visible places -->
    </div>
    <div id="tooltip"></div>
    <div id="place-popup">
        <button class="close-btn" onclick="hidePlacePopup()">√ó</button>
        <h3><span id="popup-emoji"></span><span id="popup-name"></span></h3>
        <div class="category" id="popup-category"></div>
        <div class="coords" id="popup-coords"></div>
        <div class="actions" id="popup-actions"></div>
    </div>
    <div id="controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">‚àí</button>
        <button onclick="centerOnUser()">‚óé</button>
        <button onclick="resetView()">‚ü≤</button>
        <button onclick="loadData(true)" title="Refresh">‚Üª</button>
        <button id="liveBtn" onclick="toggleLive()" title="Live mode">‚Äñ</button>
    </div>
    <div id="scale">
        <span id="scale-text">1 km</span>
        <div class="scale-bar" id="scale-bar"></div>
    </div>
</div>

<script>
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const stats = document.getElementById('stats');
const scaleText = document.getElementById('scale-text');
const scaleBar = document.getElementById('scale-bar');

let mapData = null;
let renderedPlaces = []; // For click detection
let selectedPlace = null; // Currently selected place
let userLat = null;
let userLon = null;
let userHeading = null; // Compass heading in degrees (0 = North)
let gpsHeading = null; // Heading calculated from GPS movement
let compassHeading = null; // Heading from device compass
let userSpeed = 0; // Speed in m/s

// View state - meters per pixel defines zoom
let viewState = {
    centerLat: 51.45,
    centerLon: -0.35,
    metersPerPixel: 5, // Start zoomed in for walkable view (~500m on screen)
    offsetX: 0,
    offsetY: 0,
    isDragging: false,
    lastX: 0,
    lastY: 0
};

// Category to emoji mapping
const categoryEmoji = {
    'cafe': '‚òï',
    'restaurant': 'üç¥',
    'fast_food': 'üçî',
    'pub': 'üçª',
    'bar': 'üç∏',
    'pharmacy': 'üíä',
    'hospital': 'üè•',
    'clinic': 'üè•',
    'dentist': 'ü¶∑',
    'doctors': 'ü©∫',
    'supermarket': 'üõí',
    'convenience': 'üè™',
    'bakery': 'üçû',
    'butcher': 'ü•©',
    'station': 'üöâ',
    'bus_stop': 'üöè',
    'bus_station': 'üöå',
    'cinema': 'üé¶',
    'theatre': 'üé≠',
    'park': 'üå≥',
    'library': 'üìö',
    'bank': 'üè¶',
    'atm': 'üí≥',
    'post_office': 'üìÆ',
    'fuel': '‚õΩ',
    'parking': 'üÖøÔ∏è',
    'hotel': 'üè®',
    'place_of_worship': 'üïå',
    'default': 'üìç'
};

// Get emoji for category
function getEmoji(category) {
    return categoryEmoji[category] || categoryEmoji.default;
}

// Haversine distance in meters
function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000; // Earth radius in meters
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Convert lat/lon to canvas x/y (meters from center)
function latLonToXY(lat, lon) {
    // Calculate meters from center
    const metersX = haversine(viewState.centerLat, viewState.centerLon, viewState.centerLat, lon) * 
                    (lon > viewState.centerLon ? 1 : -1);
    const metersY = haversine(viewState.centerLat, viewState.centerLon, lat, viewState.centerLon) *
                    (lat > viewState.centerLat ? -1 : 1); // Y is inverted (up = negative lat diff)
    
    // Convert meters to pixels
    const x = canvas.width / 2 + metersX / viewState.metersPerPixel + viewState.offsetX;
    const y = canvas.height / 2 + metersY / viewState.metersPerPixel + viewState.offsetY;
    
    return { x, y };
}

// Convert canvas x/y to lat/lon
function xyToLatLon(x, y) {
    const metersX = (x - canvas.width / 2 - viewState.offsetX) * viewState.metersPerPixel;
    const metersY = (y - canvas.height / 2 - viewState.offsetY) * viewState.metersPerPixel;
    
    // Approximate lat/lon from meters (at this latitude)
    const metersPerDegLat = 111320;
    const metersPerDegLon = 111320 * Math.cos(viewState.centerLat * Math.PI / 180);
    
    const lat = viewState.centerLat - metersY / metersPerDegLat;
    const lon = viewState.centerLon + metersX / metersPerDegLon;
    
    return { lat, lon };
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
}

function draw() {
    // Clear with white background
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    drawGrid();
    
    if (!mapData) return;
    
    // Draw streets first (under everything else)
    if (mapData.streets && mapData.streets.length > 0) {
        ctx.strokeStyle = '#666';
        ctx.lineWidth = Math.max(1, 3 / viewState.metersPerPixel);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        mapData.streets.forEach(street => {
            if (street.points.length < 2) return;
            
            ctx.beginPath();
            const start = latLonToXY(street.points[0][1], street.points[0][0]); // [lon, lat]
            ctx.moveTo(start.x, start.y);
            
            for (let i = 1; i < street.points.length; i++) {
                const pt = latLonToXY(street.points[i][1], street.points[i][0]);
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
        });
    }
    
    // Agents work invisibly - not rendered on map
    
    // Track drawn places for click detection
    renderedPlaces = [];
    
    // Reset globalAlpha before drawing places
    ctx.globalAlpha = 1.0;
    
    // Show places - hide when very zoomed out, show more when zoomed in
    // At 5 m/px (walkable): full detail
    // At 15+ m/px: significantly reduce, only show major ones
    // At 30+ m/px: hide all places
    const showPlaces = viewState.metersPerPixel <= 25;
    if (showPlaces) {
        // Calculate opacity: full at <=6 m/px, fade to 0.5 at 25 m/px
        let opacity = 1.0;
        if (viewState.metersPerPixel > 6) {
            opacity = 1.0 - 0.5 * (viewState.metersPerPixel - 6) / (25 - 6);
            opacity = Math.max(0.5, opacity);
        }
        ctx.globalAlpha = opacity;
        
        // Font size: smaller icons at all zoom levels
        // At 5 m/px: 18px, at 25 m/px: 10px
        const fontSize = Math.max(10, Math.min(18, 90 / viewState.metersPerPixel));
        ctx.font = fontSize + 'px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000';
        
        // Spacing: MUCH more aggressive at zoom out - show fewer places
        // At 5 m/px: tight spacing (1.5x font), at 25 m/px: very sparse (6x font)
        const spacingMultiplier = 1.5 + 4.5 * (viewState.metersPerPixel - 5) / 20;
        const minSpacing = fontSize * Math.max(1.5, spacingMultiplier);
        
        mapData.places.forEach(place => {
            const pos = latLonToXY(place.lat, place.lon);
            // Only draw if on screen (with margin for partial visibility)
            if (pos.x < -30 || pos.x > canvas.width + 30 || pos.y < -30 || pos.y > canvas.height + 30) return;
            
            // Check if too close to an already drawn place
            let tooClose = false;
            for (const drawn of renderedPlaces) {
                const dx = pos.x - drawn.x;
                const dy = pos.y - drawn.y;
                if (Math.sqrt(dx*dx + dy*dy) < minSpacing) {
                    tooClose = true;
                    break;
                }
            }
            if (tooClose) return;
            
            const emoji = getEmoji(place.category);
            ctx.fillText(emoji, pos.x, pos.y);
            renderedPlaces.push({...place, x: pos.x, y: pos.y, radius: fontSize/2 + 10});
        });
        
        // Reset alpha for subsequent drawing
        ctx.globalAlpha = 1.0;
    }
    
    // Agents work invisibly - like angels, they operate in the background
    // Not rendered on map, but still doing their work
    
    // Draw user location marker
    if (userLat && userLon) {
        const pos = latLonToXY(userLat, userLon);
        
        // Accuracy circle (assuming 50m accuracy)
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 50 / viewState.metersPerPixel, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(66, 133, 244, 0.15)';
        ctx.fill();
        
        // Heading cone (if we have heading and moving)
        // userHeading: 0=North, 90=East, 180=South, 270=West
        // Canvas: 0=right(East), PI/2=down(South), PI=left(West), -PI/2=up(North)
        // So we need: canvas_angle = (heading - 90) degrees, but heading 0 should point UP
        // Actually: North(0¬∞) -> up(-90¬∞ canvas) = -PI/2
        // Formula: canvasRad = (heading - 90) * PI/180
        if (userHeading !== null && userSpeed > 0.5) {
            const headingRad = (userHeading - 90) * Math.PI / 180;
            const coneLength = Math.max(30, userSpeed * 5);
            const coneWidth = 25 * Math.PI / 180;
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.arc(pos.x, pos.y, coneLength, headingRad - coneWidth, headingRad + coneWidth);
            ctx.closePath();
            ctx.fillStyle = 'rgba(66, 133, 244, 0.3)';
            ctx.fill();
        }
        
        // Direction arrow (if we have heading)
        if (userHeading !== null) {
            const headingRad = (userHeading - 90) * Math.PI / 180;
            const arrowLen = 20;
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(headingRad);
            
            // Arrow pointing in direction of travel (tip points right at 0 rotation)
            ctx.beginPath();
            ctx.moveTo(arrowLen, 0);   // Tip (pointing right = direction of travel after rotation)
            ctx.lineTo(-8, -8);        // Back left
            ctx.lineTo(-3, 0);         // Notch
            ctx.lineTo(-8, 8);         // Back right  
            ctx.closePath();
            ctx.fillStyle = '#4285f4';
            ctx.fill();
            ctx.restore();
        }
        
        // User dot
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#4285f4';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
    }
    
    updateScale();
}

function drawGrid() {
    // Determine grid spacing based on zoom
    let gridMeters = 1000; // 1km default
    if (viewState.metersPerPixel < 5) gridMeters = 100;     // 100m
    else if (viewState.metersPerPixel < 20) gridMeters = 500;  // 500m
    else if (viewState.metersPerPixel < 100) gridMeters = 1000; // 1km
    else gridMeters = 5000; // 5km
    
    const gridPx = gridMeters / viewState.metersPerPixel;
    
    // Get view bounds in lat/lon
    const topLeft = xyToLatLon(0, 0);
    const bottomRight = xyToLatLon(canvas.width, canvas.height);
    
    // Draw vertical lines
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    
    // Find first grid line
    const startX = Math.floor((-viewState.offsetX - canvas.width/2) * viewState.metersPerPixel / gridMeters) * gridMeters;
    const endX = startX + (canvas.width + 200) * viewState.metersPerPixel;
    
    for (let meters = startX; meters < endX; meters += gridMeters) {
        const x = canvas.width / 2 + meters / viewState.metersPerPixel + viewState.offsetX;
        if (x < -10 || x > canvas.width + 10) continue;
        
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    const startY = Math.floor((-viewState.offsetY - canvas.height/2) * viewState.metersPerPixel / gridMeters) * gridMeters;
    const endY = startY + (canvas.height + 200) * viewState.metersPerPixel;
    
    for (let meters = startY; meters < endY; meters += gridMeters) {
        const y = canvas.height / 2 + meters / viewState.metersPerPixel + viewState.offsetY;
        if (y < -10 || y > canvas.height + 10) continue;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // Draw center crosshair
    const centerX = canvas.width / 2 + viewState.offsetX;
    const centerY = canvas.height / 2 + viewState.offsetY;
    ctx.strokeStyle = '#ccc';
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, canvas.height);
    ctx.moveTo(0, centerY);
    ctx.lineTo(canvas.width, centerY);
    ctx.stroke();
    ctx.setLineDash([]);
}

function updateScale() {
    // Calculate scale bar
    let scaleMeters = 1000;
    if (viewState.metersPerPixel < 2) scaleMeters = 50;
    else if (viewState.metersPerPixel < 5) scaleMeters = 100;
    else if (viewState.metersPerPixel < 10) scaleMeters = 200;
    else if (viewState.metersPerPixel < 20) scaleMeters = 500;
    else if (viewState.metersPerPixel < 50) scaleMeters = 1000;
    else if (viewState.metersPerPixel < 100) scaleMeters = 2000;
    else scaleMeters = 5000;
    
    const scalePx = scaleMeters / viewState.metersPerPixel;
    scaleBar.style.width = scalePx + 'px';
    
    if (scaleMeters >= 1000) {
        scaleText.textContent = (scaleMeters / 1000) + ' km';
    } else {
        scaleText.textContent = scaleMeters + ' m';
    }
}

function updateStats() {
    if (!mapData) return;
    
    // Count visible places
    let visibleCount = 0;
    mapData.places.forEach(place => {
        const pos = latLonToXY(place.lat, place.lon);
        if (pos.x >= 0 && pos.x <= canvas.width && pos.y >= 0 && pos.y <= canvas.height) {
            visibleCount++;
        }
    });
    
    const streetCount = mapData.streets ? mapData.streets.length : 0;
    
    stats.innerHTML = `
        <strong>Map</strong><br>

        Places: ${mapData.places.length.toLocaleString()}<br>
        Streets: ${streetCount}<br>
        Visible: ${visibleCount.toLocaleString()}<br>
        Scale: ${Math.round(viewState.metersPerPixel)}m/px
    `;
}

let loadingData = false;
let lastLoadCenter = null;
let lastLoadRadius = 0;

function loadData(forceReload) {
    // Calculate visible radius based on screen size and zoom
    const screenDiagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
    const visibleRadius = (screenDiagonal / 2) * viewState.metersPerPixel;
    // Load 2x the visible area to allow some panning without reload
    const loadRadius = Math.max(500, Math.min(30000, visibleRadius * 2));
    
    // Check if we need to reload (moved significantly or zoomed out)
    if (!forceReload && lastLoadCenter && mapData) {
        const dist = haversineDistance(viewState.centerLat, viewState.centerLon, lastLoadCenter.lat, lastLoadCenter.lon);
        // Only reload if moved more than half the loaded radius, or zoomed out beyond loaded area
        if (dist < lastLoadRadius * 0.3 && loadRadius <= lastLoadRadius * 1.5) {
            return; // Use cached data
        }
    }
    
    if (loadingData) return;
    loadingData = true;
    
    const url = '/map?lat=' + viewState.centerLat + '&lon=' + viewState.centerLon + '&radius=' + Math.round(loadRadius);
    fetch(url, {
        headers: { 'Accept': 'application/json' }
    })
        .then(r => r.json())
        .then(data => {
            mapData = data;
            lastLoadCenter = { lat: viewState.centerLat, lon: viewState.centerLon };
            lastLoadRadius = loadRadius;
            loadingData = false;
            updateStats();
            draw();
        })
        .catch(err => {
            loadingData = false;
            stats.innerHTML = 'Error loading map data';
        });
}

// Haversine distance in meters
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Zoom controls
function showPlacePopup(item, x, y) {
    const popup = document.getElementById('place-popup');
    const emoji = item.isAgent ? 'ü§ñ' : getEmoji(item.category);
    
    document.getElementById('popup-emoji').textContent = emoji;
    document.getElementById('popup-name').textContent = item.name;
    // Format category: replace underscores with spaces, capitalize first letter
    let category = item.category || 'Place';
    category = category.replace(/_/g, ' ');
    category = category.charAt(0).toUpperCase() + category.slice(1);
    document.getElementById('popup-category').textContent = category;
    document.getElementById('popup-coords').textContent = 
        `${item.lat.toFixed(6)}, ${item.lon.toFixed(6)}`;
    
    // Build action buttons
    const actions = document.getElementById('popup-actions');
    // Include place name + coordinates for better Google Maps matching
    const encodedName = encodeURIComponent(item.name);
    const mapsUrl = `https://www.google.com/maps/search/${encodedName}/@${item.lat},${item.lon},17z`;
    const directionsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodedName}&destination_place_id=&travelmode=walking`;
    
    actions.innerHTML = `
        <a href="${mapsUrl}" target="_blank"><span>üó∫Ô∏è</span><span>Map</span></a>
        <a href="${directionsUrl}" target="_blank"><span>üö∂</span><span>Directions</span></a>
    `;
    
    // Center popup on screen
    popup.style.left = '50%';
    popup.style.top = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.display = 'block';
    
    selectedPlace = item;
}

function hidePlacePopup() {
    document.getElementById('place-popup').style.display = 'none';
    selectedPlace = null;
}

// Readable names for categories
const categoryNames = {
    'cafe': 'Cafe',
    'restaurant': 'Restaurant',
    'fast_food': 'Fast food',
    'pub': 'Pub',
    'bar': 'Bar',
    'pharmacy': 'Pharmacy',
    'hospital': 'Hospital',
    'clinic': 'Clinic',
    'dentist': 'Dentist',
    'doctors': 'Doctors',
    'supermarket': 'Supermarket',
    'convenience': 'Shop',
    'bakery': 'Bakery',
    'butcher': 'Butcher',
    'station': 'Station',
    'bus_stop': 'Bus stop',
    'bus_station': 'Bus station',
    'cinema': 'Cinema',
    'theatre': 'Theatre',
    'park': 'Park',
    'library': 'Library',
    'bank': 'Bank',
    'atm': 'ATM',
    'post_office': 'Post office',
    'fuel': 'Fuel',
    'parking': 'Parking',
    'hotel': 'Hotel',
    'place_of_worship': 'Place of worship',
    'default': 'Other'
};

function toggleLegend() {
    const legend = document.getElementById('legend');
    legend.classList.toggle('show');
    
    // Update legend with visible categories when showing
    if (legend.classList.contains('show')) {
        updateLegend();
    }
}

function updateLegend() {
    // Count categories in rendered places
    const categoryCounts = {};
    for (const place of renderedPlaces) {
        const cat = place.category || 'default';
        categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
    }
    
    // Sort by count descending
    const sorted = Object.entries(categoryCounts)
        .sort((a, b) => b[1] - a[1]);
    
    // Build legend HTML
    let html = '';
    for (const [cat, count] of sorted) {
        const emoji = getEmoji(cat);
        const name = categoryNames[cat] || cat.replace(/_/g, ' ');
        html += `<div class="legend-item"><span class="legend-emoji">${emoji}</span> ${name} (${count})</div>`;
    }
    
    if (html === '') {
        html = '<div class="legend-item">No places visible</div>';
    }
    
    document.getElementById('legend').innerHTML = html;
}

function zoomIn() {
    viewState.metersPerPixel = Math.max(0.5, viewState.metersPerPixel / 1.5);
    draw();
    updateStats();
}

function zoomOut() {
    viewState.metersPerPixel = Math.min(500, viewState.metersPerPixel * 1.5);
    draw();
    updateStats();
    loadData(); // May need more data when zooming out
}

function resetView() {
    viewState.centerLat = 51.45;
    viewState.centerLon = -0.35;
    viewState.metersPerPixel = 20;
    viewState.offsetX = 0;
    viewState.offsetY = 0;
    loadData();
}

function centerOnUser() {
    if (userLat && userLon) {
        viewState.centerLat = userLat;
        viewState.centerLon = userLon;
        viewState.offsetX = 0;
        viewState.offsetY = 0;
        loadData();
    } else {
        // Try to get user location
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(pos => {
                userLat = pos.coords.latitude;
                userLon = pos.coords.longitude;
                viewState.centerLat = userLat;
                viewState.centerLon = userLon;
                viewState.offsetX = 0;
                viewState.offsetY = 0;
                loadData();
            });
        }
    }
}

// Mouse/touch interactions
let dragStartX = 0, dragStartY = 0;
let didDrag = false;

canvas.addEventListener('mousedown', e => {
    viewState.isDragging = true;
    viewState.lastX = e.clientX;
    viewState.lastY = e.clientY;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    didDrag = false;
    canvas.style.cursor = 'grabbing';
});

canvas.addEventListener('mousemove', e => {
    if (viewState.isDragging) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        if (Math.abs(dx) > 8 || Math.abs(dy) > 8) {
            didDrag = true; // Only count as drag if moved more than 8px
        }
        viewState.offsetX += e.clientX - viewState.lastX;
        viewState.offsetY += e.clientY - viewState.lastY;
        viewState.lastX = e.clientX;
        viewState.lastY = e.clientY;
        draw();
        updateStats();
    } else {
        showTooltip(e.clientX, e.clientY);
    }
});

canvas.addEventListener('mouseup', (e) => {
    viewState.isDragging = false;
    canvas.style.cursor = 'grab';
    // Check if we need to load more data after panning
    loadData();
});

// Click to select place
canvas.addEventListener('click', (e) => {
    // Ignore clicks that were drags
    if (didDrag) {
        return;
    }
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Find clicked place (with larger hit area)
    let clicked = null;
    for (const place of renderedPlaces) {
        const dx = x - place.x;
        const dy = y - place.y;
        if (Math.sqrt(dx*dx + dy*dy) < place.radius + 10) {
            clicked = place;
            break;
        }
    }
    
    if (clicked) {
        showPlacePopup(clicked, x, y);
    } else {
        hidePlacePopup();
    }
});

canvas.addEventListener('mouseleave', () => {
    viewState.isDragging = false;
    canvas.style.cursor = 'grab';
    tooltip.style.display = 'none';
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 1.2 : 0.8;
    const oldMpp = viewState.metersPerPixel;
    const newMpp = Math.max(0.5, Math.min(500, oldMpp * factor));
    
    // Zoom around mouse position
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Distance from screen center to mouse in pixels
    const dxFromCenter = mouseX - canvas.width / 2 - viewState.offsetX;
    const dyFromCenter = mouseY - canvas.height / 2 - viewState.offsetY;
    
    // Adjust offset to keep mouse point stationary
    const scaleChange = oldMpp / newMpp;
    viewState.offsetX = viewState.offsetX * scaleChange + dxFromCenter * (1 - scaleChange);
    viewState.offsetY = viewState.offsetY * scaleChange + dyFromCenter * (1 - scaleChange);
    
    viewState.metersPerPixel = newMpp;
    draw();
    updateStats();
}, { passive: false });

function showTooltip(x, y) {
    if (!mapData) return;
    
    const searchRadius = 15; // pixels
    let nearest = null;
    let minDist = searchRadius;
    
    // Check places
    mapData.places.forEach(place => {
        const pos = latLonToXY(place.lat, place.lon);
        const dist = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));
        if (dist < minDist) {
            minDist = dist;
            nearest = place;
        }
    });
    
    // Agents work invisibly - no tooltip
    
    if (nearest) {
        tooltip.innerHTML = `<strong>${getEmoji(nearest.category)} ${nearest.name}</strong><br>${nearest.category}`;
        tooltip.style.display = 'block';
        tooltip.style.left = (x + 15) + 'px';
        tooltip.style.top = (y + 15) + 'px';
    } else {
        tooltip.style.display = 'none';
    }
}

// Touch support
let lastTouchDist = 0;
let lastTouchCenter = null;

// Touch handling with tap detection
let touchStartX = 0, touchStartY = 0;
let touchStartTime = 0;
let touchMoved = false;

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        viewState.isDragging = true;
        viewState.lastX = e.touches[0].clientX;
        viewState.lastY = e.touches[0].clientY;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        touchMoved = false;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
        lastTouchCenter = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && viewState.isDragging) {
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            touchMoved = true;
        }
        viewState.offsetX += e.touches[0].clientX - viewState.lastX;
        viewState.offsetY += e.touches[0].clientY - viewState.lastY;
        viewState.lastX = e.touches[0].clientX;
        viewState.lastY = e.touches[0].clientY;
        draw();
        updateStats();
    } else if (e.touches.length === 2) {
        touchMoved = true;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate current pinch center
        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        
        if (lastTouchDist > 0 && lastTouchCenter) {
            const factor = lastTouchDist / dist;
            const oldMpp = viewState.metersPerPixel;
            const newMpp = Math.max(0.5, Math.min(500, oldMpp * factor));
            
            // Zoom around the pinch center point
            // The pinch center should stay at the same lat/lon after zoom
            const rect = canvas.getBoundingClientRect();
            const pinchX = lastTouchCenter.x - rect.left;
            const pinchY = lastTouchCenter.y - rect.top;
            
            // Calculate how much the view shifts due to zoom
            // Distance from screen center to pinch point in old meters
            const dxFromCenter = pinchX - canvas.width / 2 - viewState.offsetX;
            const dyFromCenter = pinchY - canvas.height / 2 - viewState.offsetY;
            
            // After zoom, the same lat/lon should appear at the same screen position
            // This means we need to adjust offset to compensate for the scale change
            const scaleChange = oldMpp / newMpp;
            viewState.offsetX = viewState.offsetX * scaleChange + dxFromCenter * (1 - scaleChange);
            viewState.offsetY = viewState.offsetY * scaleChange + dyFromCenter * (1 - scaleChange);
            
            viewState.metersPerPixel = newMpp;
            draw();
            updateStats();
        }
        
        lastTouchDist = dist;
        lastTouchCenter = { x: centerX, y: centerY };
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    viewState.isDragging = false;
    lastTouchDist = 0;
    lastTouchCenter = null;
    
    // Detect tap: short duration and no significant movement
    const touchDuration = Date.now() - touchStartTime;
    if (!touchMoved && touchDuration < 300) {
        // This was a tap!
        const rect = canvas.getBoundingClientRect();
        const x = touchStartX - rect.left;
        const y = touchStartY - rect.top;
        handleTap(x, y);
    }
    
    // Check if we need to load more data after panning/zooming
    loadData();
});

// Handle tap on place or agent
function handleTap(x, y) {
    // Find tapped place
    let tapped = null;
    for (const place of renderedPlaces) {
        const dx = x - place.x;
        const dy = y - place.y;
        if (Math.sqrt(dx*dx + dy*dy) < place.radius + 15) {
            tapped = place;
            break;
        }
    }
    
    if (tapped) {
        showPlacePopup(tapped, x, y);
    } else {
        hidePlacePopup();
    }
}

// Get user location on load and watch for changes
if (navigator.geolocation) {
    // Initial position
    navigator.geolocation.getCurrentPosition(pos => {
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        userSpeed = pos.coords.speed || 0;
        viewState.centerLat = userLat;
        viewState.centerLon = userLon;
        loadData();
    }, () => {
        // Location denied, use default
        loadData();
    });
    
    // Watch position for continuous updates
    navigator.geolocation.watchPosition(pos => {
        const prevLat = userLat;
        const prevLon = userLon;
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        userSpeed = pos.coords.speed || 0;
        
        // Calculate heading from GPS movement (always, when we have meaningful movement)
        if (prevLat && prevLon) {
            const dist = haversine(prevLat, prevLon, userLat, userLon);
            // Only update heading if moved at least 3 meters (avoid noise)
            if (dist > 3) {
                const dLon = (userLon - prevLon) * Math.PI / 180;
                const y = Math.sin(dLon) * Math.cos(userLat * Math.PI / 180);
                const x = Math.cos(prevLat * Math.PI / 180) * Math.sin(userLat * Math.PI / 180) -
                          Math.sin(prevLat * Math.PI / 180) * Math.cos(userLat * Math.PI / 180) * Math.cos(dLon);
                const bearing = Math.atan2(y, x) * 180 / Math.PI;
                gpsHeading = (bearing + 360) % 360;
            }
        }
        
        // Prefer GPS heading when moving (speed > 1 m/s), otherwise use compass
        if (userSpeed > 1 && gpsHeading !== null) {
            userHeading = gpsHeading;
        } else if (compassHeading !== null) {
            userHeading = compassHeading;
        } else if (gpsHeading !== null) {
            userHeading = gpsHeading;
        }
        
        draw();
    }, null, { enableHighAccuracy: true });
} else {
    loadData();
}

// Device orientation for compass heading
let lastCompassDraw = 0;
if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', e => {
        let newHeading = null;
        // webkitCompassHeading is iOS (absolute, 0 = North)
        if (e.webkitCompassHeading !== undefined) {
            newHeading = e.webkitCompassHeading;
        } else if (e.absolute && e.alpha !== null) {
            // Android with absolute orientation
            newHeading = (360 - e.alpha) % 360;
        }
        
        if (newHeading !== null) {
            const oldHeading = compassHeading;
            compassHeading = newHeading;
            
            // Update userHeading when stationary
            if (userSpeed < 1) {
                userHeading = compassHeading;
            }
            
            // Redraw if heading changed significantly (>5 degrees) and not too frequent
            const now = Date.now();
            if (oldHeading !== null && now - lastCompassDraw > 100) {
                const diff = Math.abs(newHeading - oldHeading);
                if (diff > 5 && diff < 355) {
                    lastCompassDraw = now;
                    draw();
                }
            }
        }
    });
}

// Live mode state
let liveMode = false;
let liveInterval = null;

function toggleLive() {
    liveMode = !liveMode;
    const btn = document.getElementById('liveBtn');
    
    if (liveMode) {
        btn.textContent = '‚ñ∂';
        btn.style.background = '#e8f5e9';
        // Refresh every 5 seconds in live mode
        liveInterval = setInterval(loadData, 5000);
        loadData(); // Immediate refresh
    } else {
        btn.textContent = '‚Äñ';
        btn.style.background = '';
        if (liveInterval) {
            clearInterval(liveInterval);
            liveInterval = null;
        }
    }
}

// Initialize
window.addEventListener('resize', resize);
canvas.style.cursor = 'grab';
resize();

// Refresh data periodically (slow mode)
setInterval(() => {
    if (!liveMode) loadData();
}, 60000);
</script>
</body>
</html>
