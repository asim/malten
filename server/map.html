<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Malten Map</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #f5f5f5;
            overflow: hidden;
        }
        #map-container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; background: #fff; }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            color: #333;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        #stats strong { font-size: 14px; }
        #legend {
            position: absolute;
            bottom: 50px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            color: #333;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .legend-item { display: flex; align-items: center; margin: 3px 0; }
        .legend-emoji { width: 18px; text-align: center; margin-right: 6px; font-size: 12px; }
        
        /* Legend toggle button - hidden by default, shown on mobile */
        #legend-toggle {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
        }
        
        /* Hide legend on small screens, show toggle button */
        @media (max-width: 500px) {
            #legend { display: none; }
            #legend.show { display: block; bottom: 50px; left: 10px; }
            #legend-toggle { display: block; }
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            max-width: 200px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #controls button {
            background: rgba(255,255,255,0.95);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        #controls button:hover { background: #fff; }
        #scale {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .scale-bar {
            height: 4px;
            background: #333;
            margin-top: 4px;
        }
    </style>
</head>
<body>
<div id="map-container">
    <canvas id="map"></canvas>
    <div id="stats">Loading...</div>
    <button id="legend-toggle" onclick="toggleLegend()">‚ÑπÔ∏è</button>
    <div id="legend">
        <div class="legend-item"><span class="legend-emoji">ü§ñ</span> Agent</div>
        <div class="legend-item"><span class="legend-emoji">‚òï</span> Cafe</div>
        <div class="legend-item"><span class="legend-emoji">üç¥</span> Restaurant</div>
        <div class="legend-item"><span class="legend-emoji">üè™</span> Shop</div>
        <div class="legend-item"><span class="legend-emoji">üöè</span> Transport</div>
        <div class="legend-item"><span class="legend-emoji">üè•</span> Health</div>
        <div class="legend-item"><span class="legend-emoji">üé¶</span> Entertainment</div>
    </div>
    <div id="tooltip"></div>
    <div id="controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">‚àí</button>
        <button onclick="centerOnUser()">‚óé</button>
        <button onclick="resetView()">‚ü≤</button>
    </div>
    <div id="scale">
        <span id="scale-text">1 km</span>
        <div class="scale-bar" id="scale-bar"></div>
    </div>
</div>

<script>
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const stats = document.getElementById('stats');
const scaleText = document.getElementById('scale-text');
const scaleBar = document.getElementById('scale-bar');

let mapData = null;
let userLat = null;
let userLon = null;
let userHeading = null; // Compass heading in degrees (0 = North)
let userSpeed = 0; // Speed in m/s

// View state - meters per pixel defines zoom
let viewState = {
    centerLat: 51.45,
    centerLon: -0.35,
    metersPerPixel: 20, // Start at ~20m per pixel (good for neighborhood view)
    offsetX: 0,
    offsetY: 0,
    isDragging: false,
    lastX: 0,
    lastY: 0
};

// Category to emoji mapping
const categoryEmoji = {
    'cafe': '‚òï',
    'restaurant': 'üç¥',
    'fast_food': 'üçî',
    'pub': 'üçª',
    'bar': 'üç∏',
    'pharmacy': 'üíä',
    'hospital': 'üè•',
    'clinic': 'üè•',
    'dentist': 'ü¶∑',
    'doctors': 'ü©∫',
    'supermarket': 'üõí',
    'convenience': 'üè™',
    'bakery': 'üçû',
    'butcher': 'ü•©',
    'station': 'üöâ',
    'bus_stop': 'üöè',
    'bus_station': 'üöå',
    'cinema': 'üé¶',
    'theatre': 'üé≠',
    'park': 'üå≥',
    'library': 'üìö',
    'bank': 'üè¶',
    'atm': 'üí≥',
    'post_office': 'üìÆ',
    'fuel': '‚õΩ',
    'parking': 'üÖøÔ∏è',
    'hotel': 'üè®',
    'place_of_worship': 'üïå',
    'default': 'üìç'
};

// Get emoji for category
function getEmoji(category) {
    return categoryEmoji[category] || categoryEmoji.default;
}

// Haversine distance in meters
function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000; // Earth radius in meters
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Convert lat/lon to canvas x/y (meters from center)
function latLonToXY(lat, lon) {
    // Calculate meters from center
    const metersX = haversine(viewState.centerLat, viewState.centerLon, viewState.centerLat, lon) * 
                    (lon > viewState.centerLon ? 1 : -1);
    const metersY = haversine(viewState.centerLat, viewState.centerLon, lat, viewState.centerLon) *
                    (lat > viewState.centerLat ? -1 : 1); // Y is inverted (up = negative lat diff)
    
    // Convert meters to pixels
    const x = canvas.width / 2 + metersX / viewState.metersPerPixel + viewState.offsetX;
    const y = canvas.height / 2 + metersY / viewState.metersPerPixel + viewState.offsetY;
    
    return { x, y };
}

// Convert canvas x/y to lat/lon
function xyToLatLon(x, y) {
    const metersX = (x - canvas.width / 2 - viewState.offsetX) * viewState.metersPerPixel;
    const metersY = (y - canvas.height / 2 - viewState.offsetY) * viewState.metersPerPixel;
    
    // Approximate lat/lon from meters (at this latitude)
    const metersPerDegLat = 111320;
    const metersPerDegLon = 111320 * Math.cos(viewState.centerLat * Math.PI / 180);
    
    const lat = viewState.centerLat - metersY / metersPerDegLat;
    const lon = viewState.centerLon + metersX / metersPerDegLon;
    
    return { lat, lon };
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
}

function draw() {
    // Clear with white background
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    drawGrid();
    
    if (!mapData) return;
    
    // Draw streets first (under everything else)
    if (mapData.streets && mapData.streets.length > 0) {
        ctx.strokeStyle = '#666';
        ctx.lineWidth = Math.max(1, 3 / viewState.metersPerPixel);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        mapData.streets.forEach(street => {
            if (street.points.length < 2) return;
            
            ctx.beginPath();
            const start = latLonToXY(street.points[0][1], street.points[0][0]); // [lon, lat]
            ctx.moveTo(start.x, start.y);
            
            for (let i = 1; i < street.points.length; i++) {
                const pt = latLonToXY(street.points[i][1], street.points[i][0]);
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
        });
    }
    
    // Draw agent coverage circles (faint)
    mapData.agents.forEach(agent => {
        const pos = latLonToXY(agent.lat, agent.lon);
        const radiusPx = agent.radius / viewState.metersPerPixel;
        
        if (radiusPx > 5) { // Only draw if visible
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radiusPx, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(66, 133, 244, 0.05)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(66, 133, 244, 0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    });
    
    // Draw places as emojis
    // Limit density when very zoomed in to avoid overlap
    const fontSize = Math.max(14, Math.min(24, 300 / viewState.metersPerPixel));
    ctx.font = fontSize + 'px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Track drawn positions to avoid overlap
    const drawnPositions = [];
    const minSpacing = fontSize * 1.5; // Minimum pixels between emojis
    
    mapData.places.forEach(place => {
        const pos = latLonToXY(place.lat, place.lon);
        if (pos.x < -20 || pos.x > canvas.width + 20 || pos.y < -20 || pos.y > canvas.height + 20) return;
        
        // Check if too close to an already drawn place
        let tooClose = false;
        for (const drawn of drawnPositions) {
            const dx = pos.x - drawn.x;
            const dy = pos.y - drawn.y;
            if (Math.sqrt(dx*dx + dy*dy) < minSpacing) {
                tooClose = true;
                break;
            }
        }
        if (tooClose) return;
        
        const emoji = getEmoji(place.category);
        ctx.fillText(emoji, pos.x, pos.y);
        drawnPositions.push(pos);
    });
    
    // Draw agents (larger, labeled)
    ctx.font = '16px sans-serif';
    mapData.agents.forEach(agent => {
        const pos = latLonToXY(agent.lat, agent.lon);
        if (pos.x < -30 || pos.x > canvas.width + 30 || pos.y < -30 || pos.y > canvas.height + 30) return;
        
        // Agent emoji
        ctx.fillText('ü§ñ', pos.x, pos.y);
        
        // Agent label (only at medium zoom - not too far, not too close)
        if (viewState.metersPerPixel > 3 && viewState.metersPerPixel < 50) {
            ctx.font = '11px sans-serif';
            ctx.fillStyle = '#333';
            ctx.fillText(agent.name, pos.x, pos.y + 18);
            ctx.font = '16px sans-serif';
        }
    });
    
    // Draw user location marker
    if (userLat && userLon) {
        const pos = latLonToXY(userLat, userLon);
        
        // Accuracy circle (assuming 50m accuracy)
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 50 / viewState.metersPerPixel, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(66, 133, 244, 0.15)';
        ctx.fill();
        
        // Heading cone (if we have heading and moving)
        if (userHeading !== null && userSpeed > 0.5) {
            const headingRad = (userHeading - 90) * Math.PI / 180; // Convert to canvas coords
            const coneLength = Math.max(30, userSpeed * 5); // Longer cone when faster
            const coneWidth = 25 * Math.PI / 180; // 25 degree cone
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.arc(pos.x, pos.y, coneLength, headingRad - coneWidth, headingRad + coneWidth);
            ctx.closePath();
            ctx.fillStyle = 'rgba(66, 133, 244, 0.3)';
            ctx.fill();
        }
        
        // Direction arrow (if we have heading)
        if (userHeading !== null) {
            const headingRad = (userHeading - 90) * Math.PI / 180;
            const arrowLen = 20;
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(headingRad);
            
            // Arrow
            ctx.beginPath();
            ctx.moveTo(arrowLen, 0);
            ctx.lineTo(-5, -6);
            ctx.lineTo(-5, 6);
            ctx.closePath();
            ctx.fillStyle = '#4285f4';
            ctx.fill();
            ctx.restore();
        }
        
        // User dot
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#4285f4';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
    }
    
    updateScale();
}

function drawGrid() {
    // Determine grid spacing based on zoom
    let gridMeters = 1000; // 1km default
    if (viewState.metersPerPixel < 5) gridMeters = 100;     // 100m
    else if (viewState.metersPerPixel < 20) gridMeters = 500;  // 500m
    else if (viewState.metersPerPixel < 100) gridMeters = 1000; // 1km
    else gridMeters = 5000; // 5km
    
    const gridPx = gridMeters / viewState.metersPerPixel;
    
    // Get view bounds in lat/lon
    const topLeft = xyToLatLon(0, 0);
    const bottomRight = xyToLatLon(canvas.width, canvas.height);
    
    // Draw vertical lines
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    
    // Find first grid line
    const startX = Math.floor((-viewState.offsetX - canvas.width/2) * viewState.metersPerPixel / gridMeters) * gridMeters;
    const endX = startX + (canvas.width + 200) * viewState.metersPerPixel;
    
    for (let meters = startX; meters < endX; meters += gridMeters) {
        const x = canvas.width / 2 + meters / viewState.metersPerPixel + viewState.offsetX;
        if (x < -10 || x > canvas.width + 10) continue;
        
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    const startY = Math.floor((-viewState.offsetY - canvas.height/2) * viewState.metersPerPixel / gridMeters) * gridMeters;
    const endY = startY + (canvas.height + 200) * viewState.metersPerPixel;
    
    for (let meters = startY; meters < endY; meters += gridMeters) {
        const y = canvas.height / 2 + meters / viewState.metersPerPixel + viewState.offsetY;
        if (y < -10 || y > canvas.height + 10) continue;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // Draw center crosshair
    const centerX = canvas.width / 2 + viewState.offsetX;
    const centerY = canvas.height / 2 + viewState.offsetY;
    ctx.strokeStyle = '#ccc';
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, canvas.height);
    ctx.moveTo(0, centerY);
    ctx.lineTo(canvas.width, centerY);
    ctx.stroke();
    ctx.setLineDash([]);
}

function updateScale() {
    // Calculate scale bar
    let scaleMeters = 1000;
    if (viewState.metersPerPixel < 2) scaleMeters = 50;
    else if (viewState.metersPerPixel < 5) scaleMeters = 100;
    else if (viewState.metersPerPixel < 10) scaleMeters = 200;
    else if (viewState.metersPerPixel < 20) scaleMeters = 500;
    else if (viewState.metersPerPixel < 50) scaleMeters = 1000;
    else if (viewState.metersPerPixel < 100) scaleMeters = 2000;
    else scaleMeters = 5000;
    
    const scalePx = scaleMeters / viewState.metersPerPixel;
    scaleBar.style.width = scalePx + 'px';
    
    if (scaleMeters >= 1000) {
        scaleText.textContent = (scaleMeters / 1000) + ' km';
    } else {
        scaleText.textContent = scaleMeters + ' m';
    }
}

function updateStats() {
    if (!mapData) return;
    
    // Count visible places
    let visibleCount = 0;
    mapData.places.forEach(place => {
        const pos = latLonToXY(place.lat, place.lon);
        if (pos.x >= 0 && pos.x <= canvas.width && pos.y >= 0 && pos.y <= canvas.height) {
            visibleCount++;
        }
    });
    
    const streetCount = mapData.streets ? mapData.streets.length : 0;
    
    stats.innerHTML = `
        <strong>Malten Spatial Index</strong><br>
        Agents: ${mapData.agents.length}<br>
        Places: ${mapData.places.length.toLocaleString()}<br>
        Streets: ${streetCount}<br>
        Visible: ${visibleCount.toLocaleString()}<br>
        Scale: ${Math.round(viewState.metersPerPixel)}m/px
    `;
}

function loadData() {
    // Load data centered on current view
    const url = '/map?lat=' + viewState.centerLat + '&lon=' + viewState.centerLon + '&radius=30000';
    fetch(url, {
        headers: { 'Accept': 'application/json' }
    })
        .then(r => r.json())
        .then(data => {
            mapData = data;
            updateStats();
            draw();
        })
        .catch(err => {
            stats.innerHTML = 'Error loading map data';
        });
}

// Zoom controls
function toggleLegend() {
    document.getElementById('legend').classList.toggle('show');
}

function zoomIn() {
    viewState.metersPerPixel = Math.max(0.5, viewState.metersPerPixel / 1.5);
    draw();
    updateStats();
}

function zoomOut() {
    viewState.metersPerPixel = Math.min(500, viewState.metersPerPixel * 1.5);
    draw();
    updateStats();
}

function resetView() {
    viewState.centerLat = 51.45;
    viewState.centerLon = -0.35;
    viewState.metersPerPixel = 20;
    viewState.offsetX = 0;
    viewState.offsetY = 0;
    loadData();
}

function centerOnUser() {
    if (userLat && userLon) {
        viewState.centerLat = userLat;
        viewState.centerLon = userLon;
        viewState.offsetX = 0;
        viewState.offsetY = 0;
        loadData();
    } else {
        // Try to get user location
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(pos => {
                userLat = pos.coords.latitude;
                userLon = pos.coords.longitude;
                viewState.centerLat = userLat;
                viewState.centerLon = userLon;
                viewState.offsetX = 0;
                viewState.offsetY = 0;
                loadData();
            });
        }
    }
}

// Mouse/touch interactions
canvas.addEventListener('mousedown', e => {
    viewState.isDragging = true;
    viewState.lastX = e.clientX;
    viewState.lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
});

canvas.addEventListener('mousemove', e => {
    if (viewState.isDragging) {
        viewState.offsetX += e.clientX - viewState.lastX;
        viewState.offsetY += e.clientY - viewState.lastY;
        viewState.lastX = e.clientX;
        viewState.lastY = e.clientY;
        draw();
        updateStats();
    } else {
        showTooltip(e.clientX, e.clientY);
    }
});

canvas.addEventListener('mouseup', () => {
    viewState.isDragging = false;
    canvas.style.cursor = 'grab';
});

canvas.addEventListener('mouseleave', () => {
    viewState.isDragging = false;
    canvas.style.cursor = 'grab';
    tooltip.style.display = 'none';
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 1.2 : 0.8;
    viewState.metersPerPixel = Math.max(0.5, Math.min(500, viewState.metersPerPixel * factor));
    draw();
    updateStats();
}, { passive: false });

function showTooltip(x, y) {
    if (!mapData) return;
    
    const searchRadius = 15; // pixels
    let nearest = null;
    let minDist = searchRadius;
    
    // Check places
    mapData.places.forEach(place => {
        const pos = latLonToXY(place.lat, place.lon);
        const dist = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));
        if (dist < minDist) {
            minDist = dist;
            nearest = place;
        }
    });
    
    // Check agents
    mapData.agents.forEach(agent => {
        const pos = latLonToXY(agent.lat, agent.lon);
        const dist = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));
        if (dist < minDist) {
            minDist = dist;
            nearest = { ...agent, isAgent: true };
        }
    });
    
    if (nearest) {
        if (nearest.isAgent) {
            tooltip.innerHTML = `<strong>ü§ñ ${nearest.name}</strong><br>Status: ${nearest.status}<br>POIs: ${nearest.poiCount}`;
        } else {
            tooltip.innerHTML = `<strong>${getEmoji(nearest.category)} ${nearest.name}</strong><br>${nearest.category}`;
        }
        tooltip.style.display = 'block';
        tooltip.style.left = (x + 15) + 'px';
        tooltip.style.top = (y + 15) + 'px';
    } else {
        tooltip.style.display = 'none';
    }
}

// Touch support
let lastTouchDist = 0;
let lastTouchCenter = null;

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        viewState.isDragging = true;
        viewState.lastX = e.touches[0].clientX;
        viewState.lastY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
        lastTouchCenter = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && viewState.isDragging) {
        viewState.offsetX += e.touches[0].clientX - viewState.lastX;
        viewState.offsetY += e.touches[0].clientY - viewState.lastY;
        viewState.lastX = e.touches[0].clientX;
        viewState.lastY = e.touches[0].clientY;
        draw();
        updateStats();
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (lastTouchDist > 0) {
            const factor = lastTouchDist / dist;
            viewState.metersPerPixel = Math.max(0.5, Math.min(500, viewState.metersPerPixel * factor));
            draw();
            updateStats();
        }
        lastTouchDist = dist;
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    viewState.isDragging = false;
    lastTouchDist = 0;
    lastTouchCenter = null;
});

// Get user location on load and watch for changes
if (navigator.geolocation) {
    // Initial position
    navigator.geolocation.getCurrentPosition(pos => {
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        userSpeed = pos.coords.speed || 0;
        viewState.centerLat = userLat;
        viewState.centerLon = userLon;
        loadData();
    }, () => {
        // Location denied, use default
        loadData();
    });
    
    // Watch position for continuous updates
    navigator.geolocation.watchPosition(pos => {
        const prevLat = userLat;
        const prevLon = userLon;
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        userSpeed = pos.coords.speed || 0;
        
        // Calculate heading from movement if no compass
        if (prevLat && prevLon && userHeading === null) {
            const dLon = (userLon - prevLon) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(userLat * Math.PI / 180);
            const x = Math.cos(prevLat * Math.PI / 180) * Math.sin(userLat * Math.PI / 180) -
                      Math.sin(prevLat * Math.PI / 180) * Math.cos(userLat * Math.PI / 180) * Math.cos(dLon);
            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            userHeading = (bearing + 360) % 360;
        }
        draw();
    }, null, { enableHighAccuracy: true });
} else {
    loadData();
}

// Device orientation for compass heading
if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', e => {
        // webkitCompassHeading is iOS, alpha is Android (but needs adjustment)
        if (e.webkitCompassHeading !== undefined) {
            userHeading = e.webkitCompassHeading;
        } else if (e.alpha !== null) {
            // Android: alpha is rotation around z-axis, 0 when pointing north
            // But it's relative to device orientation, not absolute
            userHeading = (360 - e.alpha) % 360;
        }
        draw();
    });
}

// Initialize
window.addEventListener('resize', resize);
canvas.style.cursor = 'grab';
resize();

// Refresh data periodically
setInterval(loadData, 60000);
</script>
</body>
</html>
